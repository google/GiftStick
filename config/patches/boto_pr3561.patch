--- /usr/local/lib/python3.7/dist-packages/boto-2.49.0-py3.7.egg/boto/connection.py	2020-01-16 12:52:15.775888311 +0000
+++ /tmp/connection.py	2020-01-16 12:48:30.202139299 +0000
@@ -793,21 +793,18 @@
         else:
             sock = socket.create_connection((self.proxy, int(self.proxy_port)))
         boto.log.debug("Proxy connection: CONNECT %s HTTP/1.0\r\n", host)
-        sock.sendall(("CONNECT %s HTTP/1.0\r\n" % host).encode())
-        sock.sendall(("User-Agent: %s\r\n" % UserAgent).encode())
+        sock.sendall("CONNECT %s HTTP/1.0\r\n" % host)
+        sock.sendall("User-Agent: %s\r\n" % UserAgent)
         if self.proxy_user and self.proxy_pass:
             for k, v in self.get_proxy_auth_header().items():
-                sock.sendall(("%s: %s\r\n" % (k, v)).encode())
+                sock.sendall("%s: %s\r\n" % (k, v))
             # See discussion about this config option at
             # https://groups.google.com/forum/?fromgroups#!topic/boto-dev/teenFvOq2Cc
             if config.getbool('Boto', 'send_crlf_after_proxy_auth_headers', False):
-                sock.sendall(("\r\n").encode())
+                sock.sendall("\r\n")
         else:
-            sock.sendall(("\r\n").encode())
-        kwargs = {'sock': sock, 'debuglevel': self.debug}
-        if six.PY2:
-            kwargs['strict'] = True
-        resp = http_client.HTTPResponse(**kwargs)
+            sock.sendall("\r\n")
+        resp = http_client.HTTPResponse(sock, strict=True, debuglevel=self.debug)
         resp.begin()
 
         if resp.status != 200:
--- /usr/local/lib/python3.7/dist-packages/boto-2.49.0-py3.7.egg/boto/s3/key.py	2020-01-16 12:55:28.355560049 +0000
+++ /tmp/key.py	2020-01-16 12:58:45.754246347 +0000
@@ -849,9 +849,9 @@
                 chunk_len = len(chunk)
                 data_len += chunk_len
                 if chunked_transfer:
-                    http_conn.send(('%x;\r\n' % chunk_len).encode())
+                    http_conn.send('%x;\r\n' % chunk_len)
                     http_conn.send(chunk)
-                    http_conn.send('\r\n'.encode())
+                    http_conn.send('\r\n')
                 else:
                     http_conn.send(chunk)
                 for alg in digesters:
@@ -879,9 +879,9 @@
                 self.local_hashes[alg] = digesters[alg].digest()
 
             if chunked_transfer:
-                http_conn.send('0\r\n'.encode())
+                http_conn.send('0\r\n')
                     # http_conn.send("Content-MD5: %s\r\n" % self.base64md5)
-                http_conn.send('\r\n'.encode())
+                http_conn.send('\r\n')
 
             if cb and (cb_count <= 1 or i > 0) and data_len > 0:
                 cb(data_len, cb_size)
